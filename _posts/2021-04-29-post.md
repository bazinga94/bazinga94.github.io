---
title:  "[iOS] View의 Display & Layout 관련 메소드"
excerpt: "자주 사용하지만 완벽하게 모르는 iOS 뷰 레이아웃 관련 메소드"
toc: true
toc_label: "목차"    # 목차 명
toc_icon: "cog"     # 목차 아이콘 ex) fish, carrot ...
toc_sticky: true    # 목차 상단에 고정
categories:
  - iOS
tags:
  - UIView
  - Layout
  - Display
last_modified_at: 2021-04-29T00:00:00-00:00
---

뷰의 layout 생명주기

### layoutSubViews()

뷰컨트롤러가 레이아웃을 설정하는 과정
1.	viewWillLayoutSubviews()
2.	View controller의 컨텐츠 뷰가 layoutSubViews(): 현재 정보를 가지고 레이아웃 배치, subview들도 동일한 메소드 호출
3.	viewDidLayoutSubviews()

---

1. viewWillLayoutSubviews()
- 해당 뷰의 bounds*가 변하면 뷰는 subview들의 위치를 조정
- 용도 : 뷰 추가&제거, 뷰 크기 변경, 레이아웃 제약 변경, 뷰와 관련된 프로퍼티 갱신
 
 * bounds : 자기 자신을 기준으로 위치나 크기를 나타낸 것
   frame : super view를 기준으로 위치나 크기를 나타낸 것
  해당내용 참고 : ios-development.tistory.com/111
 
2. layoutSubViews()
- 뷰의 크기 발생(Auto Layout) -> autoresizingMask프로퍼티를 설정하여 superview의 크기가 변경되었을 때 어떻게 대응할지 정의하는 곳
- 해당 뷰의 크기가 변경될 시 subview들에게 auto resizing동작을 적용하며, subview들에게 연쇄적으로 적용
 
3. viewDidLayoutSubviews()
- 레이아웃이 결정되고 나서 호출
- 용도 : tableView.reLoadData(), 다른 뷰들의 컨텐츠 갱신


### setNeedsLayout()

*Main Run Loop
어플리케이션이 실행되면 iOS의 UIApplication이 매인 스레드에서 main run loop를 실행시킵니다. main run loop는 돌아가면서 터치 이벤트, 위치의 변화, 디바이스의 회전 등의 각종 이벤트들을 처리하게 됩니다. 이러한 처리 과정은 각 이벤트들에 알맞는 핸들러를 찾아 그들에게 권한을 처리 권한을 위임하며 진행됩니다.

버튼의 터치 이벤트를 @IBAction 메소드가 처리하는 것과 같습니다.
이렇게 발생한 이벤트들을 모두 처리하고 권한이 다시 main run loop로 돌아오게 되고 이 시점을 update cycle이라고 합니다.

Update Cycle
main run loop에서 이벤트가 처리되는 과정에서 버튼을 누르면 크기나 위치가 이동하는 애니메이션과 같이 layout이나 position 값을 바꾸는 핸들러가 실행될 때도 있습니다. 이러한 변화는 즉각적으로 반영되는 것이 아닙니다.

시스템은 이러한 layout이나 position이 변화되는 View를 체크합니다. 그리고 모든 핸들러가 종료되고 main run loop로 권한이 다시 돌아오는 시점인 update cycle에서 이런 View들의 값을 바꿔주어 position이나 layout의 변화를 적용시킵니다.

즉 postion이나 layout 값을 변경하는 코드와 실제로 변경된 값이 반영되는 시점에는 시간차가 존재한다는 뜻입니다. (오호)

*LayoutSubviews()
View의 값을 호출한 즉시 변경시켜주는 메소드
호출 되면 해당 View의 모든 subview들의 layoutSubviews 도 연달아 호출한다
1. View의 크기를 조절할 때
2. Subview를 추가할 때
3. 사용자가 UIScrollView를 스크롤할 때
4. 디바이스를 회전시켰을 때 (Portrait, Landscape)
5. View의 Auto Layout contraint 값을 변경시켰을 때

layoutSubviews를 update cycle에서 호출 되게끔 자동으로 예약해주는 상황!

하지만

이렇게 자동이 아니라 수동으로 예약 할 수 있는 메소드도 있다 -> “setNeedsLayout()”
이 메소드를 호출한 View는 재계산되어야 하는 View라고 수동으로 체크가 되며 update cycle에서 layoutSubviews가 호출되게 됩니다.
이 메소드는 비동기적으로 작동하기 때문에 호출되고 바로 반환됩니다. 그리고 View의 보여지는 모습은 update cycle에 들어갔을 때 바뀌게 됩니다.


### setNeedsDisplay()

해당 뷰 인스턴스가 다음 드로잉 사이클에서 다시 그려져야 한다는걸 알린다
드로잉 사이클이 오는 여부는 뷰의 모양이나 내용이 변경된 경우에만 해당된다.(?) 뷰의 위치 또는 크기가 변경 되는건 해당되지 않는다. ( 뷰의 컨텐츠가 변경된 경우 )

다음 뷰의 드로잉 사이클에서 -> func draw(CGRect) 를 통해 뷰를 업데이트 시켜줘야 한다고 알림

그럼 func draw(CGRect) 랑 뷰의 드로잉 사이클이란 뭘까…

기본적으로 draw(CGRect)는 아무것도 실행하지 않는다.
우리가 override해서 구현해야 하는데
최초 한번 처음 등장할때를 제외 하고 view의 frame을 변화 시켜도 draw 는 호출되지 않음!
근데 이상한게 뷰에 아무런 조치를 취하지 않아도 setNeedsDisplay만 호출해도 draw가 실행됨
-> draw 가 트리거 되게 하려면 contentMode 를 redraw로 해주면 됨!! (신기~)
https://developer.apple.com/documentation/uikit/uiview/1622621-frame?language=objc

1. View를 부분적으로 가리고 있던 다른 View이동 또는 제거
2. hidden 프로퍼티를 No로 설정하여, 이전에 숨겨진 View를 다시 볼 수 있게 만들기
3. View를 화면밖으로 스크롤한다음, 화면으로 다시 이동하기
4. View의 setNeedsDisplay 또는 setNeedsDisplayInRect: 메소드를 명시적으로 호출하기

draw(CGRect)를 트리거 시키는 경우들

근데 평소에 왜 잘 업데이트 되는거 같지?? 
-> 평소에 view property가 변경될때 마다 내부의 setNeedsDisplay()가 호출된다!!

그럼 언제 쓰냐~~?
-> 커스텀 뷰를 만들고 draw 메소드에 뭔가 구현하고 어떤 사건에 의해 명시적인 업데이트가 필요하면 setNeedsDisplay()를 호출해야 한다.


### layoutIfNeeded()
이건 setNeedsLayout() 과 비슷하다. 수동으로 예약하는 메소드지만 해당 예약을 바로 실행시키는 동기적으로 작동하는 메소드이다. Update cycle이 와서 layoutSubviews를 호출시키는게 아니라 즉시 layoutSubviews를 발동시키는 메소드

-> 따라서 이는 그 즉시 값이 변경되어햐 하는 애니메이션에서 자주 사용된다.


### displayIfNeeded()
